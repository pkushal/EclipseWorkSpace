The main idea is to make the threads run simultaneously.

The two ways to implement the threads in java is:
	1. extend the Thread class
	2. implement the runnable class and pass it to the constructor
	   of the thread class.

	3. If we just have one thread to run and we don't want to take the hassle to make all these then we can use the anonymous class and make it easy.


Option 1:
package demo1;

class Runner extends Thread {

	@Override
	//Need to override the run method and once I do start(), it will look for the run method
	public void run() {
		for (int i = 0; i < 10; i++) {
			System.out.println("hello " + i);
		}
		try {
			Thread.sleep(1000); // need to surround the sleep with try and catch block
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

}

public class App {
	public static void main(String[] args) {
		Runner runner1 = new Runner();
		runner1.start(); // do not do runner1.run(); just start the thread
		
		Runner runner2 = new Runner();
		runner2.start();
	}
}


Option 2:

class Runner implements Runnable {

	@Override
	public void run() {
		for (int i = 0; i < 10; i++) {
			System.out.println("hello " + i);
		}
		try {
			Thread.sleep(100);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

}

public class App2 {
	public static void main(String[] args) {
		Thread t1 = new Thread(new Runner());
		Thread t2 = new Thread(new Runner());
		t1.start();
		t2.start();
	}
}



Option 3:

/*
 * Here we have instantiated the Thread class and passed the instance of the Runnable in the constructor.
 * To make the instance of the Runnable we have use the anonymous class as Runnable is a interface.
 * Finally start the thread
 */
public class App3 {
	public static void main(String[] args) {
		Thread t1 = new Thread(new Runnable() {

			@Override
			public void run() {
				for (int i = 0; i < 10; i++) {
					System.out.println("hello " + i);
				}
				try {
					Thread.sleep(100);
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}

			}

		});
		t1.start();
	}
}



Basic synchronization:

The volatile keyword prevents thread caching the variables when
they are not changing the variables. In the process of optimizing  java will decide that, I am not changing a variable,
say,x so I am not gonna look for it every time and I am gonna cache it. But what might happens some other can change that variable x and in that case the first thread will not know.
So we use the volatile keyword infront of those variables and make sure they are not cached.

import java.util.Scanner;

/*
 * Volatile keyword prevents caching the variables when they are not changed by that thread.
 */
class Processor extends Thread {
	private volatile boolean running = true;

	public void run() {
		while (running) {
			for (int i = 0; i < 10; i++) {
				System.out.println("hello " + i);
			}
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}

	public void shutDown() {
		running = false;
	}
}

public class App_Volatile_KeyWord {
	public static void main(String[] args) {
		Processor proc1 = new Processor();
		proc1.start();

		System.out.println("Press Enter to stop: ");
		Scanner scan = new Scanner(System.in);
		scan.nextLine();
		proc1.shutDown();
	}
}


The next problem is interleaving... multiple thread has to access a variable and increase the count by one. If all the threads access the variable at once, then they will all read the same value and all incresase by 1, when they had to increase the count one by one.



package basicThreadSynchronization;

public class App_synchronized_keyword {
	private int count = 0;

	public void doWork() {

		Thread t1 = new Thread(new Runnable() {

			@Override
			public void run() {
				for (int i = 0; i < 10000; i++) {
					count++;
				}
			}
		});

		Thread t2 = new Thread(new Runnable() {

			@Override
			public void run() {
				for (int i = 0; i < 10000; i++) {
					count++;
				}

			}
		});

		t1.start();
		t2.start();
		/*
		 * here the problem is that all the run will run simultaneously and the
		 * thread that runs the main method of the program will also be
		 * executing simultaneously. so when I do syso, the it will display the
		 * current value of the count It will not wait for the threads t1 and t2
		 * to complete their task. To address this problem we need to invoke the
		 * join method on the thread t1 and t2. The join method will pause the
		 * thread that has called the t1 thread, i.e., main thread until the
		 * thread t1 finishes what it needs to do.
		 */
		try {
			t1.join();
			t2.join();
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		/*
		 * Now the interleaving problem:
		 * To address the interleaving problem, we can make that integer atomic. Atomic Integer is a specialized class that has a method which can make
		 * the increment in one step insted of 3 steps like in count++(count= count+1... step 1: load the value of count, step 2: increment the count, step 3: 
		 * load the value of count)
		 */
		
		System.out
				.println("Expected count value is 20000, the count value is: "
						+ count);
	}

	public static void main(String[] args) {
		App_synchronized_keyword app = new App_synchronized_keyword();
		app.doWork();
	}
}


Solution: 
Synchronized keyword

package basicThreadSynchronization;

/*
 * Every object in java has a intrinsic lock and it can be access by one thread at one time. After the thread is done processing, it will release the
 * intrinsic lock so that others can use it. The method with synchronized keyword needs to have that intrinsic lock to process further. This will solve the 
 * problem as only one thread can increment at once and there will be no interleaving. This intrinsic lock is aka mutex.
 */
public class App_synchronized_keyword {
	private int count = 0;

	public synchronized void increment() {
		count++;
	}

	public void doWork() {

		Thread t1 = new Thread(new Runnable() {

			@Override
			public void run() {
				for (int i = 0; i < 10000; i++) {
					increment();
				}
			}
		});

		Thread t2 = new Thread(new Runnable() {

			@Override
			public void run() {
				for (int i = 0; i < 10000; i++) {
					increment();
				}

			}
		});

		t1.start();
		t2.start();

		try {
			t1.join();
			t2.join();
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	
		System.out
				.println("Expected count value is 20000, the count value is: "
						+ count);
	}

	public static void main(String[] args) {
		App_synchronized_keyword app = new App_synchronized_keyword();
		app.doWork();
	}
}


IF WE ARE USING THE SYNCHRONIZED KEYWORD, THEN NO NEED TO 
USE THE VOLATILE KEYWORD.
VOLATILE KEYWORD WILL MAKE THE VARIABLES VISIBLE FROM ALL THREADS